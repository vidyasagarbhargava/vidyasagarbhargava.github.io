{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Introduction to Graph Neural Networks\"\n",
        "description: A Graph is the type of data structure that contains nodes and edges. A node can be a person, place, or thing, and the edges define the relationship between nodes. The edges can be directed and undirected based on directional dependencies. \n",
        "author: \"Vidyasagar Bhargava\"\n",
        "date: \"8/6/2024\"\n",
        "categories:\n",
        "  - graphs\n",
        "  - neural networks\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "## Graph Data Structure\n",
        "\n",
        "A Graph consists of edges and nodes. These nodes are also known as vertices. Now these nodes are the information centers of the graph and edges are the channels through which this information flows from one node to its neighbouring node.\n",
        "\n",
        "\n",
        "\n",
        "$$\n",
        "G = (V, E)\n",
        "$$\n"
      ],
      "id": "3af124f4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: false\n",
        "\n",
        "import networkx as nx\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Create the directed graph\n",
        "H = nx.DiGraph()\n",
        "\n",
        "# Adding nodes\n",
        "H.add_nodes_from(\n",
        "    [\n",
        "        (0, {\"color\": \"blue\", \"size\": 250}),\n",
        "        (1, {\"color\": \"yellow\", \"size\": 400}),\n",
        "        (2, {\"color\": \"orange\", \"size\": 150}),\n",
        "        (3, {\"color\": \"red\", \"size\": 600}),\n",
        "    ]\n",
        ")\n",
        "\n",
        "# Adding edges\n",
        "H.add_edges_from([(0, 1), (1, 2), (1, 0), (1, 3), (2, 3), (3, 0)])\n",
        "\n",
        "# Getting node attributes\n",
        "node_colors = nx.get_node_attributes(H, \"color\").values()\n",
        "colors = list(node_colors)\n",
        "node_sizes = nx.get_node_attributes(H, \"size\").values()\n",
        "sizes = list(node_sizes)\n",
        "\n",
        "# Plotting the graph\n",
        "plt.figure(figsize=(8, 6))  # Set the figure size\n",
        "ax = plt.gca()  # Get current axis\n",
        "\n",
        "# Set both the figure and axis background to transparent\n",
        "plt.gcf().patch.set_alpha(0.0)  # Transparent figure background\n",
        "ax.set_facecolor(\"none\")  # Transparent axis background\n",
        "\n",
        "nx.draw(H, with_labels=True, node_color=colors, node_size=sizes)\n",
        "\n",
        "# Save the figure with a transparent background\n",
        "plt.savefig(\"graph.png\", format=\"png\", transparent=True)\n",
        "\n",
        "# Display the plot\n",
        "plt.show()"
      ],
      "id": "9aea8c69",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We represent a graph using Adjancency Matrix. An Adjancey matrix is square matrix $v*v$ where $v$ is number of nodes in graph\n",
        "\n",
        "\n",
        "$$\n",
        "Adjancey Matrix = \\begin{array}{c|ccc}\n",
        "    & \\text{0} & \\text{1} & \\text{2} & \\text{3}\\\\ \\hline\n",
        "\\text{0} & 0 & 1 & 0 & 0\\\\\n",
        "\\text{1} & 1 & 0 & 1 & 1\\\\\n",
        "\\text{2} & 0 & 0 & 0 & 1\\\\\n",
        "\\text{3} & 1 & 0 & 0 & 0\n",
        "\\end{array}\n",
        "$$\n",
        "\n",
        "\n",
        "> To understand how to build an adjancey matrix we have to understand the types of graphs.\n",
        "\n",
        "## Types of Graphs\n",
        "\n",
        "**Based on directions**  \n",
        "\n",
        "- Directed  \n",
        "- Undirected  \n",
        "\n",
        "\n",
        "In directed graph information flows in a particular direction whereas in Undirected graph there is no particular direction for flow of direction.\n"
      ],
      "id": "c0849030"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: false\n",
        "\n",
        "import networkx as nx\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "# Create the directed graph\n",
        "H = nx.DiGraph()\n",
        "\n",
        "# Adding nodes\n",
        "H.add_nodes_from(\n",
        "    [\n",
        "        (0, {\"color\": \"blue\", \"size\": 250}),\n",
        "        (1, {\"color\": \"yellow\", \"size\": 400}),\n",
        "        (2, {\"color\": \"orange\", \"size\": 150}),\n",
        "        (3, {\"color\": \"red\", \"size\": 600}),\n",
        "    ]\n",
        ")\n",
        "\n",
        "# Adding edges\n",
        "H.add_edges_from([(0, 1), (1, 2), (1, 0), (1, 3), (2, 3), (3, 0)])\n",
        "\n",
        "# Getting node attributes\n",
        "node_colors = nx.get_node_attributes(H, \"color\").values()\n",
        "colors = list(node_colors)\n",
        "node_sizes = nx.get_node_attributes(H, \"size\").values()\n",
        "sizes = list(node_sizes)\n",
        "\n",
        "# Create the undirected graph using the same nodes and edges\n",
        "G = nx.Graph()\n",
        "G.add_nodes_from(H.nodes(data=True))\n",
        "G.add_edges_from(H.edges())\n",
        "\n",
        "# Set up the figure with two subplots side by side\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 6))  # 1 row, 2 columns\n",
        "\n",
        "# Plot the directed graph on the first subplot\n",
        "ax1.set_title(\"Directed Graph\")\n",
        "ax1.set_facecolor(\"none\")  # Transparent axis background\n",
        "nx.draw(H, ax=ax1, with_labels=True, node_color=colors, node_size=sizes)\n",
        "\n",
        "# Plot the undirected graph on the second subplot\n",
        "ax2.set_title(\"Undirected Graph\")\n",
        "ax2.set_facecolor(\"none\")  # Transparent axis background\n",
        "nx.draw(G, ax=ax2, with_labels=True, node_color=colors, node_size=sizes)\n",
        "\n",
        "# Set the figure background to transparent\n",
        "plt.gcf().patch.set_alpha(0.0)\n",
        "\n",
        "# Save the figure with a transparent background (optional)\n",
        "plt.savefig(\"side_by_side_graphs.png\", format=\"png\", transparent=True)\n",
        "\n",
        "# Display the plot\n",
        "plt.show()"
      ],
      "id": "44da19a1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This directed graph is similar to earlier graph and we will get same adjancey matrix for it.\n",
        "\n",
        "Now let's create adjancey matrix for an undirected graph\n",
        "\n",
        "$$\n",
        "Adjancey Matrix  = \\begin{array}{c|ccc}\n",
        "    & \\text{0} & \\text{1} & \\text{2} & \\text{3}\\\\ \\hline\n",
        "\\text{0} & 0 & 1 & 0 & 1\\\\\n",
        "\\text{1} & 1 & 0 & 1 & 1\\\\\n",
        "\\text{2} & 0 & 1 & 0 & 1\\\\\n",
        "\\text{3} & 1 & 1 & 1 & 0\n",
        "\\end{array}\n",
        "$$\n",
        "\n",
        "A undirected graphs produces symmetric adjancey matrix. \n",
        "\n",
        "**Based of weight**  \n",
        "\n",
        "- Weighted   \n",
        "- Unweighted  \n",
        "\n",
        "In weighted graph the values at edges determines that how important that edge is between two nodes whereas in unweighted graph all weights are equal and their value is 1.\n"
      ],
      "id": "802f87fc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: false\n",
        "\n",
        "import networkx as nx\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Create the unweighted graph\n",
        "G_unweighted = nx.Graph()\n",
        "\n",
        "# Adding nodes\n",
        "G_unweighted.add_nodes_from(\n",
        "    [\n",
        "        (0, {\"color\": \"blue\", \"size\": 250}),\n",
        "        (1, {\"color\": \"yellow\", \"size\": 400}),\n",
        "        (2, {\"color\": \"orange\", \"size\": 150}),\n",
        "        (3, {\"color\": \"red\", \"size\": 600}),\n",
        "    ]\n",
        ")\n",
        "\n",
        "# Adding edges without weights\n",
        "G_unweighted.add_edges_from([(0, 1), (1, 2), (1, 0), (1, 3), (2, 3), (3, 0)])\n",
        "\n",
        "# Create the weighted graph using the same nodes but with weights on the edges\n",
        "G_weighted = nx.Graph()\n",
        "G_weighted.add_nodes_from(G_unweighted.nodes(data=True))\n",
        "\n",
        "# Adding edges with weights\n",
        "G_weighted.add_edges_from(\n",
        "    [\n",
        "        (0, 1, {\"weight\": 2}),\n",
        "        (1, 2, {\"weight\": 5}),\n",
        "        (1, 0, {\"weight\": 3}),\n",
        "        (1, 3, {\"weight\": 4}),\n",
        "        (2, 3, {\"weight\": 1}),\n",
        "        (3, 0, {\"weight\": 6}),\n",
        "    ]\n",
        ")\n",
        "\n",
        "# Getting node attributes\n",
        "node_colors = nx.get_node_attributes(G_unweighted, \"color\").values()\n",
        "colors = list(node_colors)\n",
        "node_sizes = nx.get_node_attributes(G_unweighted, \"size\").values()\n",
        "sizes = list(node_sizes)\n",
        "\n",
        "# Define edge weights for the weighted graph\n",
        "edge_weights = nx.get_edge_attributes(G_weighted, \"weight\")\n",
        "\n",
        "# Set up the figure with two subplots side by side\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 6))  # 1 row, 2 columns\n",
        "\n",
        "# Plot the unweighted graph on the first subplot\n",
        "ax1.set_title(\"Unweighted Graph\")\n",
        "ax1.set_facecolor(\"none\")  # Transparent axis background\n",
        "nx.draw(G_unweighted, ax=ax1, with_labels=True, node_color=colors, node_size=sizes)\n",
        "\n",
        "# Plot the weighted graph on the second subplot\n",
        "ax2.set_title(\"Weighted Graph\")\n",
        "ax2.set_facecolor(\"none\")  # Transparent axis background\n",
        "\n",
        "# Draw the weighted graph with labels\n",
        "pos = nx.spring_layout(G_weighted)  # Positioning for nodes\n",
        "\n",
        "nx.draw(\n",
        "    G_weighted,\n",
        "    ax=ax2,\n",
        "    with_labels=True,\n",
        "    node_color=colors,\n",
        "    node_size=sizes,\n",
        "    edge_color=\"black\",\n",
        "    width=1.0,\n",
        ")  # Keep edge width the same\n",
        "\n",
        "# Draw edge labels\n",
        "nx.draw_networkx_edge_labels(\n",
        "    G_weighted,\n",
        "    pos,\n",
        "    edge_labels=edge_weights,\n",
        "    ax=ax2,\n",
        "    label_pos=0.5,\n",
        "    font_size=10,\n",
        "    bbox=dict(facecolor=\"white\", edgecolor=\"none\"),\n",
        ")\n",
        "\n",
        "# Set the figure background to transparent\n",
        "plt.gcf().patch.set_alpha(0.0)\n",
        "\n",
        "# Save the figure with a transparent background (optional)\n",
        "plt.savefig(\n",
        "    \"side_by_side_weighted_unweighted_graphs_with_centered_labels.png\",\n",
        "    format=\"png\",\n",
        "    transparent=True,\n",
        ")\n",
        "\n",
        "# Display the plot\n",
        "plt.show()"
      ],
      "id": "3e013ee7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's create adjancey matrix for a weighted graph  \n",
        "\n",
        "$$\n",
        "Adjancey Matrix = \\begin{array}{c|ccc}\n",
        "    & \\text{0} & \\text{1} & \\text{2} & \\text{3}\\\\ \\hline\n",
        "\\text{0} & 0 & 6 & 0 & 3\\\\\n",
        "\\text{1} & 6 & 0 & 1 & 4\\\\\n",
        "\\text{2} & 0 & 1 & 0 & 5\\\\\n",
        "\\text{3} & 3 & 4 & 5 & 0\n",
        "\\end{array}\n",
        "$$\n",
        "\n",
        "\n",
        "## Why do we need GNN?\n",
        "\n",
        "Traditional neural networks can deal with data like images, text which belongs to data called as euclidean data. But many real world problems cannot be considered as eculidean data and so these non-euclidean data can be modeled as a graph. Also we can train these graphs to do many interesting tasks.\n",
        "\n",
        "Examples of non-euclidean data :- \n",
        "\n",
        "- Social Networks  \n",
        "- Molecules  \n",
        "- Amino acids in protein  \n",
        "\n",
        "All these non-eculidean structres can be modeled as graphs.\n",
        "\n",
        "\n",
        "## Where is Graph Data used?  \n",
        "\n",
        "- Analyse social relationship, interaction and recommend content  \n",
        "- Model user-item interactions and make personalized recommendations \n",
        "- Use knowledge graphs to organize and connect structure data\n",
        "\n",
        "\n",
        "## Tasks with GNN  \n",
        "\n",
        "- Node level\n",
        "- Edge level\n",
        "- Graph level\n",
        "\n",
        "\n",
        "\n",
        "## Message Passing Mechanism   \n",
        "Process by which nodes in a graph exchange information with neighbouring nodes inorder to update their own information.Let's understand this with an example.\n",
        "\n",
        "Suppose there are 4 colleagues A, B, C, D who planned to go for trip and but didn't finalized their destination yet.So they are going to finalize their destination.\n",
        "\n",
        "First A takes a paper and writes its preferred destination on a paper  and pass it to friend B. Now  B reads location written by A and based on location written by A, the colleague B updates its location on the paper and passes paper to C and then C reads the location written by A and B, then he further updates the location again and pass it D. Now D gets to know all these locations written by A , B and C and based on that he writes its preferred location and he summarize at end.\n",
        "\n",
        "\n",
        "In above anology 4 colleagues are 4 nodes and paper these colleagues passed is message function and destination written on these paper are features of the graph.\n",
        "\n",
        "\n",
        "## What happens in GNN ?\n",
        "\n",
        "Step 1 - GNN convert all the features vectors into nodes  \n",
        "Step 2 - Message Passing   \n",
        "Step 3 - Message Aggregation    \n",
        "Step 4 - Node updation  \n",
        "\n",
        "\n",
        "This happens in 1 hidden layer of graph neural networks and likewise there are multiple hidden layers are present in GNN and this process iterates over multiple layers.  The output of it can be \n",
        "\n",
        "-  node embedding\n",
        "-  edge embedding\n",
        "-  graph embedding \n",
        "\n",
        "\n",
        "\n",
        "## Types of GNN\n",
        "\n",
        "- Graph Convolutional Networks (GCN)  \n",
        "- Graph Auto-Encoder Networks  \n",
        "- Recurrent Graph Neural Networks (RGNN)  \n",
        "- Gated Graph Neural Networks (GGNN)  \n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Disadvantages of Graphs Neural Networks \n",
        "There are few drawbacks of using GNNs. Understanding them help us to determine when to use them and how to optimize the performance of our machine learning model.  \n",
        "\n",
        "1. Neural Networks can have multiple layers and can go deep to obtain better performance however **GNNs are shallow networks** mostly with 3 layers.  This limit us from achieving SOTA performance on large datasets.  \n",
        "\n",
        "2. The **graph structures are constantly changing**, making it harder to train a model on it.  \n",
        "\n",
        "3. Deploying the model to production faces **scalability issues** as these networks are computationally expensive.  \n"
      ],
      "id": "f86a4f76"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}