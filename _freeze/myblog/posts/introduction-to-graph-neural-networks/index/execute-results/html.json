{
  "hash": "39cf96b1fe9b4aa72db6eeb29e7aa64c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Introduction to Graph Neural Networks\"\ndescription: A Graph is the type of data structure that contains nodes and edges. A node can be a person, place, or thing, and the edges define the relationship between nodes. The edges can be directed and undirected based on directional dependencies. \nauthor: \"Vidyasagar Bhargava\"\ndate: \"8/6/2024\"\ncategories:\n  - graphs\n  - neural networks\n---\n\n## Graph Data Structure\n\nA Graph consists of edges and nodes. These nodes are also known as vertices. Now these nodes are the information centers of the graph and edges are the channels through which this information flows from one node to its neighbouring node.\n\n\n\n$$\nG = (V, E)\n$$\n\n::: {#7ba145fe .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-1.png){width=614 height=463}\n:::\n:::\n\n\nWe represent a graph using Adjancency Matrix. An Adjancey matrix is square matrix $v*v$ where $v$ is number of nodes in graph\n\n\n$$\nAdjancey Matrix = \\begin{array}{c|ccc}\n    & \\text{0} & \\text{1} & \\text{2} & \\text{3}\\\\ \\hline\n\\text{0} & 0 & 1 & 0 & 0\\\\\n\\text{1} & 1 & 0 & 1 & 1\\\\\n\\text{2} & 0 & 0 & 0 & 1\\\\\n\\text{3} & 1 & 0 & 0 & 0\n\\end{array}\n$$\n\n\n> To understand how to build an adjancey matrix we have to understand the types of graphs.\n\n## Types of Graphs\n\n**Based on directions**  \n\n- Directed  \n- Undirected  \n\n\nIn directed graph information flows in a particular direction whereas in Undirected graph there is no particular direction for flow of direction.\n\n::: {#9d9e843e .cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=763 height=483}\n:::\n:::\n\n\nThis directed graph is similar to earlier graph and we will get same adjancey matrix for it.\n\nNow let's create adjancey matrix for an undirected graph\n\n$$\nAdjancey Matrix  = \\begin{array}{c|ccc}\n    & \\text{0} & \\text{1} & \\text{2} & \\text{3}\\\\ \\hline\n\\text{0} & 0 & 1 & 0 & 1\\\\\n\\text{1} & 1 & 0 & 1 & 1\\\\\n\\text{2} & 0 & 1 & 0 & 1\\\\\n\\text{3} & 1 & 1 & 1 & 0\n\\end{array}\n$$\n\nA undirected graphs produces symmetric adjancey matrix. \n\n**Based of weight**  \n\n- Weighted   \n- Unweighted  \n\nIn weighted graph the values at edges determines that how important that edge is between two nodes whereas in unweighted graph all weights are equal and their value is 1.\n\n::: {#663f626d .cell execution_count=3}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-1.png){width=763 height=483}\n:::\n:::\n\n\nLet's create adjancey matrix for a weighted graph  \n\n$$\nAdjancey Matrix = \\begin{array}{c|ccc}\n    & \\text{0} & \\text{1} & \\text{2} & \\text{3}\\\\ \\hline\n\\text{0} & 0 & 6 & 0 & 3\\\\\n\\text{1} & 6 & 0 & 1 & 4\\\\\n\\text{2} & 0 & 1 & 0 & 5\\\\\n\\text{3} & 3 & 4 & 5 & 0\n\\end{array}\n$$\n\n\n## Why do we need GNN?\n\nTraditional neural networks can deal with data like images, text which belongs to data called as euclidean data. But many real world problems cannot be considered as eculidean data and so these non-euclidean data can be modeled as a graph. Also we can train these graphs to do many interesting tasks.\n\nExamples of non-euclidean data :- \n\n- Social Networks  \n- Molecules  \n- Amino acids in protein  \n\nAll these non-eculidean structres can be modeled as graphs.\n\n\n## Where is Graph Data used?  \n\n- Analyse social relationship, interaction and recommend content  \n- Model user-item interactions and make personalized recommendations \n- Use knowledge graphs to organize and connect structure data\n\n\n## Tasks with GNN  \n\n- Node level\n- Edge level\n- Graph level\n\n\n\n## Message Passing Mechanism   \nProcess by which nodes in a graph exchange information with neighbouring nodes inorder to update their own information.Let's understand this with an example.\n\nSuppose there are 4 colleagues A, B, C, D who planned to go for trip and but didn't finalized their destination yet.So they are going to finalize their destination.\n\nFirst A takes a paper and writes its preferred destination on a paper  and pass it to friend B. Now  B reads location written by A and based on location written by A, the colleague B updates its location on the paper and passes paper to C and then C reads the location written by A and B, then he further updates the location again and pass it D. Now D gets to know all these locations written by A , B and C and based on that he writes its preferred location and he summarize at end.\n\n\nIn above anology 4 colleagues are 4 nodes and paper these colleagues passed is message function and destination written on these paper are features of the graph.\n\n\n## What happens in GNN ?\n\nStep 1 - GNN convert all the features vectors into nodes  \nStep 2 - Message Passing   \nStep 3 - Message Aggregation    \nStep 4 - Node updation  \n\n\nThis happens in 1 hidden layer of graph neural networks and likewise there are multiple hidden layers are present in GNN and this process iterates over multiple layers.  The output of it can be \n\n-  node embedding\n-  edge embedding\n-  graph embedding \n\n\n\n## Types of GNN\n\n- Graph Convolutional Networks (GCN)  \n- Graph Auto-Encoder Networks  \n- Recurrent Graph Neural Networks (RGNN)  \n- Gated Graph Neural Networks (GGNN)  \n\n\n\n\n## Disadvantages of Graphs Neural Networks \nThere are few drawbacks of using GNNs. Understanding them help us to determine when to use them and how to optimize the performance of our machine learning model.  \n\n1. Neural Networks can have multiple layers and can go deep to obtain better performance however **GNNs are shallow networks** mostly with 3 layers.  This limit us from achieving SOTA performance on large datasets.  \n\n2. The **graph structures are constantly changing**, making it harder to train a model on it.  \n\n3. Deploying the model to production faces **scalability issues** as these networks are computationally expensive.  \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}